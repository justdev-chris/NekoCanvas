<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>NekoCanvas Ultra - üêæ</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/fabric.js/5.3.1/fabric.min.js"></script>
    <script src="https://unpkg.com/gifler@0.1.0/gifler.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/gif.js@0.2.0/dist/gif.js"></script>
    <style>
        :root { --bg: #0d0d0d; --panel: #161616; --accent: #00f2ff; --text: #f0f0f0; }
        body { font-family: 'Segoe UI', sans-serif; background: var(--bg); color: var(--text); margin: 0; display: flex; height: 100vh; overflow: hidden; }
        
        /* SIDEBAR */
        .sidebar { width: 300px; background: var(--panel); border-right: 1px solid #333; display: flex; flex-direction: column; padding: 15px; gap: 8px; overflow-y: auto; flex-shrink: 0; }
        h2 { color: var(--accent); margin: 0; font-size: 1.2rem; border-bottom: 1px solid #333; padding-bottom: 10px; }
        .section { background: #222; padding: 10px; border-radius: 8px; margin-bottom: 5px; }
        label { font-size: 0.65rem; color: #888; text-transform: uppercase; display: block; margin-bottom: 5px; font-weight: bold; }
        
        /* BUTTONS */
        button { background: var(--accent); color: #000; border: none; padding: 8px; border-radius: 4px; cursor: pointer; font-weight: bold; width: 100%; transition: 0.2s; margin-top: 2px; }
        button:hover { filter: brightness(1.2); }
        .btn-alt { background: #444; color: white; }
        .btn-danger { background: #622; color: #f99; }
        input, select { background: #111; color: #fff; border: 1px solid #444; padding: 6px; width: 100%; border-radius: 4px; box-sizing: border-box; }
        
        /* WORKSPACE */
        .workspace { flex: 1; display: flex; flex-direction: column; background: #000; position: relative; }
        .top-bar { background: #1a1a1a; padding: 8px; border-bottom: 1px solid #333; display: flex; gap: 15px; align-items: center; font-size: 0.8rem; justify-content: center; }
        
        /* THE CANVAS AREA */
        .canvas-container-wrapper { 
            flex: 1; 
            display: flex; 
            align-items: center; 
            justify-content: center; 
            overflow: auto; 
            background: #111; /* Darker background so the white canvas pops */
            padding: 50px;
        }

        /* Forces the actual fabric canvas to be visible */
        .canvas-container {
            box-shadow: 0 0 20px rgba(0,0,0,0.5);
            border: 2px solid #333;
        }
    </style>
</head>
<body>

    <div class="sidebar">
        <h2>üêæ NekoCanvas Ultra</h2>

        <div class="section">
            <label>History</label>
            <div style="display:grid; grid-template-columns: 1fr 1fr; gap:5px;">
                <button onclick="undo()" class="btn-alt">Undo</button>
                <button onclick="redo()" class="btn-alt">Redo</button>
            </div>
            <button onclick="deleteObj()" class="btn-danger" style="margin-top:5px;">Delete (Del)</button>
        </div>

        <div class="section">
            <label>Canvas Size</label>
            <div style="display:flex; gap:5px;">
                <input type="number" id="canW" value="800">
                <input type="number" id="canH" value="600">
            </div>
            <button onclick="resizeCanvas()" class="btn-alt">Update Canvas</button>
        </div>

        <div class="section">
            <label>Perspective & Warp</label>
            <div style="display:grid; grid-template-columns: 1fr 1fr; gap:5px;">
                <button onclick="applyWarp('skewX')" class="btn-alt">Skew X</button>
                <button onclick="applyWarp('skewY')" class="btn-alt">Skew Y</button>
                <button onclick="applyFlip('flipX')" class="btn-alt">Flip H</button>
                <button onclick="applyFlip('flipY')" class="btn-alt">Flip V</button>
            </div>
            <button onclick="unlockWarp()" style="margin-top:5px;">Unlock Free-Warp</button>
        </div>

        <div class="section">
            <label>Brush</label>
            <button onclick="toggleDraw()" id="drawBtn">Mode: Selection</button>
            <input type="color" id="brushColor" value="#00f2ff">
            <input type="range" id="brushSize" min="1" max="100" value="10">
        </div>

        <div class="section">
            <label>Import</label>
            <input type="file" id="fileIn" accept="image/*,.gif">
        </div>

        <div class="section">
            <label>Project</label>
            <button onclick="saveNeko()" class="btn-alt">Save .neko</button>
            <button onclick="document.getElementById('loadIn').click()" class="btn-alt">Load .neko</button>
            <input type="file" id="loadIn" accept=".neko" style="display:none">
        </div>

        <div class="section">
            <label>Export</label>
            <select id="exportFormat">
                <option value="png">PNG</option>
                <option value="jpeg">JPEG</option>
            </select>
            <button onclick="exportImg()">Export Image</button>
            <button onclick="exportGIF()" style="background:#f1c40f;">Export GIF</button>
        </div>
    </div>

    <div class="workspace">
        <div class="top-bar">
            <span>X: <input type="number" id="offX" style="width:50px" onchange="syncMove()"></span>
            <span>Y: <input type="number" id="offY" style="width:50px" onchange="syncMove()"></span>
            <span>Size: <input type="number" id="offS" step="0.1" style="width:50px" onchange="syncMove()"></span>
        </div>
        <div class="canvas-container-wrapper">
            <canvas id="c"></canvas>
        </div>
    </div>

    <script>
        const canvas = new fabric.Canvas('c', {
            width: 800, height: 600, backgroundColor: '#ffffff', preserveObjectStacking: true
        });

        // Loop to keep GIFs playing
        function renderLoop() {
            canvas.renderAll();
            fabric.util.requestAnimFrame(renderLoop);
        }
        renderLoop();

        let history = [];
        let redoStack = [];
        let locked = false;

        function saveState() {
            if (locked) return;
            history.push(JSON.stringify(canvas));
            if (history.length > 20) history.shift();
            redoStack = [];
        }

        function undo() {
            if (history.length <= 1) return;
            locked = true;
            redoStack.push(history.pop());
            canvas.loadFromJSON(history[history.length - 1], () => {
                canvas.renderAll();
                locked = false;
            });
        }

        function redo() {
            if (!redoStack.length) return;
            locked = true;
            const state = redoStack.pop();
            history.push(state);
            canvas.loadFromJSON(state, () => {
                canvas.renderAll();
                locked = false;
            });
        }

        function resizeCanvas() {
            const w = parseInt(document.getElementById('canW').value);
            const h = parseInt(document.getElementById('canH').value);
            canvas.setDimensions({ width: w, height: h });
            saveState();
        }

        function toggleDraw() {
            canvas.isDrawingMode = !canvas.isDrawingMode;
            document.getElementById('drawBtn').innerText = canvas.isDrawingMode ? "Mode: Drawing" : "Mode: Selection";
            canvas.freeDrawingBrush.color = document.getElementById('brushColor').value;
            canvas.freeDrawingBrush.width = parseInt(document.getElementById('brushSize').value);
        }

        function deleteObj() {
            canvas.remove(...canvas.getActiveObjects());
            canvas.discardActiveObject();
            saveState();
        }

        function applyWarp(prop) {
            const obj = canvas.getActiveObject();
            if (obj) { obj.set(prop, (obj[prop] || 0) + 10); canvas.renderAll(); saveState(); }
        }

        function applyFlip(prop) {
            const obj = canvas.getActiveObject();
            if (obj) { obj.set(prop, !obj[prop]); canvas.renderAll(); saveState(); }
        }

        function unlockWarp() {
            const obj = canvas.getActiveObject();
            if (obj) { obj.set({ lockUniScaling: false, centeredScaling: false }); canvas.renderAll(); }
        }

        function syncMove() {
            const obj = canvas.getActiveObject();
            if (obj) {
                obj.set({
                    left: parseInt(document.getElementById('offX').value),
                    top: parseInt(document.getElementById('offY').value),
                    scaleX: parseFloat(document.getElementById('offS').value),
                    scaleY: parseFloat(document.getElementById('offS').value)
                }).setCoords();
                canvas.renderAll();
                saveState();
            }
        }

        // GIF IMPORT FIX
        document.getElementById('fileIn').addEventListener('change', function(e) {
            const file = e.target.files[0];
            if (!file) return;
            const url = URL.createObjectURL(file);

            if (file.type === 'image/gif') {
                gifler(url).get(function(anim) {
                    const temp = document.createElement('canvas');
                    temp.width = anim.width; temp.height = anim.height;
                    const fabGif = new fabric.Image(temp, { left: 50, top: 50 });
                    canvas.add(fabGif);
                    anim.animateInCanvas(temp);
                    saveState();
                });
            } else {
                fabric.Image.fromURL(url, (img) => {
                    img.scale(0.5);
                    canvas.add(img);
                    saveState();
                });
            }
        });

        // KEYS
        window.addEventListener('keydown', (e) => {
            if (e.ctrlKey && e.key === 'z') { e.preventDefault(); undo(); }
            if (e.ctrlKey && e.key === 'y') { e.preventDefault(); redo(); }
            const act = canvas.getActiveObject();
            if (!act) return;
            if (e.key === 'Delete' || e.key === 'Backspace') deleteObj();
            const s = e.shiftKey ? 10 : 1;
            if (e.key === 'ArrowUp') act.top -= s;
            if (e.key === 'ArrowDown') act.top += s;
            if (e.key === 'ArrowLeft') act.left -= s;
            if (e.key === 'ArrowRight') act.left += s;
            act.setCoords();
            canvas.renderAll();
        });

        function saveNeko() {
            const blob = new Blob([JSON.stringify(canvas)], {type: "application/json"});
            const a = document.createElement('a');
            a.href = URL.createObjectURL(blob);
            a.download = "art.neko";
            a.click();
        }

        document.getElementById('loadIn').addEventListener('change', function(e) {
            const reader = new FileReader();
            reader.onload = (f) => {
                canvas.loadFromJSON(f.target.result, () => {
                    canvas.renderAll();
                    saveState();
                });
            };
            reader.readAsText(e.target.files[0]);
        });

        function exportImg() {
            const f = document.getElementById('exportFormat').value;
            const a = document.createElement('a');
            a.download = `neko_export.${f}`;
            a.href = canvas.toDataURL({ format: f });
            a.click();
        }

        function exportGIF() {
            const gif = new GIF({ workers: 2, quality: 10, width: canvas.width, height: canvas.height, workerScript: 'https://cdn.jsdelivr.net/npm/gif.js@0.2.0/dist/gif.worker.js' });
            let count = 0;
            const timer = setInterval(() => {
                gif.addFrame(canvas.getElement(), {delay: 100, copy: true});
                if (++count >= 20) {
                    clearInterval(timer);
                    gif.on('finished', (b) => {
                        const a = document.createElement('a');
                        a.href = URL.createObjectURL(b); a.download = 'neko_anim.gif'; a.click();
                    });
                    gif.render();
                }
            }, 100);
        }

        canvas.on('object:modified', saveState);
        canvas.on('selection:created', (e) => {
            if (!e.target) return;
            document.getElementById('offX').value = Math.round(e.target.left);
            document.getElementById('offY').value = Math.round(e.target.top);
            document.getElementById('offS').value = e.target.scaleX ? e.target.scaleX.toFixed(2) : 1;
        });

        saveState();
    </script>
</body>
</html>
